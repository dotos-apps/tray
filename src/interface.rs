// This code was autogenerated with `dbus-codegen-rust --client blocking -o ./src/interface.rs --file ./src/StatusNotifierItem.xml`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_tree as tree;

pub trait OrgKdeStatusNotifierItem {
    fn context_menu(&self, x_: i32, y_: i32) -> Result<(), tree::MethodErr>;
    fn activate(&self, x_: i32, y_: i32) -> Result<(), tree::MethodErr>;
    fn secondary_activate(&self, x_: i32, y_: i32) -> Result<(), tree::MethodErr>;
    fn scroll(&self, delta: i32, orientation: &str) -> Result<(), tree::MethodErr>;
    fn category(&self) -> Result<String, tree::MethodErr>;
    fn id(&self) -> Result<String, tree::MethodErr>;
    fn title(&self) -> Result<String, tree::MethodErr>;
    fn status(&self) -> Result<String, tree::MethodErr>;
    fn window_id(&self) -> Result<i32, tree::MethodErr>;
    fn icon_theme_path(&self) -> Result<String, tree::MethodErr>;
    fn menu(&self) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn item_is_menu(&self) -> Result<bool, tree::MethodErr>;
    fn icon_name(&self) -> Result<String, tree::MethodErr>;
    fn icon_pixmap(&self) -> Result<Vec<(i32, i32, Vec<u8>)>, tree::MethodErr>;
    fn overlay_icon_name(&self) -> Result<String, tree::MethodErr>;
    fn overlay_icon_pixmap(&self) -> Result<Vec<(i32, i32, Vec<u8>)>, tree::MethodErr>;
    fn attention_icon_name(&self) -> Result<String, tree::MethodErr>;
    fn attention_icon_pixmap(&self) -> Result<Vec<(i32, i32, Vec<u8>)>, tree::MethodErr>;
    fn attention_movie_name(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_kde_status_notifier_item_server<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    D::Signal: Default,
    T: OrgKdeStatusNotifierItem,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.kde.StatusNotifierItem", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let d = fclone(minfo);
        d.context_menu(x_, y_)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("ContextMenu", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let d = fclone(minfo);
        d.activate(x_, y_)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Activate", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let d = fclone(minfo);
        d.secondary_activate(x_, y_)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("SecondaryActivate", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let delta: i32 = i.read()?;
        let orientation: &str = i.read()?;
        let d = fclone(minfo);
        d.scroll(delta, orientation)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Scroll", Default::default(), h);
    let m = m.in_arg(("delta", "i"));
    let m = m.in_arg(("orientation", "s"));
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("Category", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.category()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Id", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.id()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Title", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.title()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Status", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.status()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("WindowId", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.window_id()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("IconThemePath", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.icon_theme_path()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<dbus::Path, _>("Menu", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.menu()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ItemIsMenu", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.item_is_menu()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("IconName", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.icon_name()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<(i32, i32, Vec<u8>)>, _>("IconPixmap", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.icon_pixmap()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("OverlayIconName", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.overlay_icon_name()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p =
        factory.property::<Vec<(i32, i32, Vec<u8>)>, _>("OverlayIconPixmap", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.overlay_icon_pixmap()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("AttentionIconName", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.attention_icon_name()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p =
        factory.property::<Vec<(i32, i32, Vec<u8>)>, _>("AttentionIconPixmap", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.attention_icon_pixmap()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("AttentionMovieName", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.attention_movie_name()?);
        Ok(())
    });
    let i = i.add_p(p);
    let s = factory.signal("NewTitle", Default::default());
    let i = i.add_s(s);
    let s = factory.signal("NewIcon", Default::default());
    let i = i.add_s(s);
    let s = factory.signal("NewAttentionIcon", Default::default());
    let i = i.add_s(s);
    let s = factory.signal("NewOverlayIcon", Default::default());
    let i = i.add_s(s);
    let s = factory.signal("NewStatus", Default::default());
    let s = s.arg(("status", "s"));
    let i = i.add_s(s);
    let s = factory.signal("NewIconThemePath", Default::default());
    let s = s.arg(("icon_theme_path", "s"));
    let i = i.add_s(s);
    let s = factory.signal("NewMenu", Default::default());
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewTitle {}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewTitle {
    fn append(&self, _: &mut arg::IterAppend) {}
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewTitle {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewTitle {})
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewTitle {
    const NAME: &'static str = "NewTitle";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewIcon {}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewIcon {
    fn append(&self, _: &mut arg::IterAppend) {}
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewIcon {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewIcon {})
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewIcon {
    const NAME: &'static str = "NewIcon";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewAttentionIcon {}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewAttentionIcon {
    fn append(&self, _: &mut arg::IterAppend) {}
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewAttentionIcon {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewAttentionIcon {})
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewAttentionIcon {
    const NAME: &'static str = "NewAttentionIcon";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewOverlayIcon {}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewOverlayIcon {
    fn append(&self, _: &mut arg::IterAppend) {}
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewOverlayIcon {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewOverlayIcon {})
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewOverlayIcon {
    const NAME: &'static str = "NewOverlayIcon";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewStatus {
    pub status: String,
}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewStatus {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.status, i);
    }
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewStatus {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewStatus { status: i.read()? })
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewStatus {
    const NAME: &'static str = "NewStatus";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewIconThemePath {
    pub icon_theme_path: String,
}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewIconThemePath {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.icon_theme_path, i);
    }
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewIconThemePath {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewIconThemePath {
            icon_theme_path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewIconThemePath {
    const NAME: &'static str = "NewIconThemePath";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewMenu {}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewMenu {
    fn append(&self, _: &mut arg::IterAppend) {}
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewMenu {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewMenu {})
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewMenu {
    const NAME: &'static str = "NewMenu";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}
